#! /usr/bin/env python3
# mdf - Quickly and easily make beautiful PDFs from markdown.
#
# Copyright 2020-2022 Marcel Moreaux
# Licensed under BSD 3-clause. See LICENSE for details.

import os
import sys
import time
import datetime
import argparse
import subprocess
import logging

import markdown
import weasyprint



# Strip enclosing <p> tags
def strip_p(s):
	if s.lower().startswith('<p>') and s.lower().endswith('</p>'):
		return s[3:-4]
	else:
		return s



class Document:
	def __init__(self, filename, config):
		self.config = config
		if not filename.endswith('.md'):
			filename += '.md'
		self.md_path = filename
		self.pdf_path = os.path.splitext(self.md_path)[0] + '.pdf'
		self.html = ''
		self.dependencies = [self.md_path]  # FIXME: should include CSS, images


	def uptodate(self):
		try:
			md_mtime = os.stat(self.md_path).st_mtime
		except FileNotFoundError:
			md_mtime = 0

		try:
			pdf_mtime = os.stat(self.pdf_path).st_mtime
		except FileNotFoundError:
			pdf_mtime = -1

		return md_mtime <= pdf_mtime


	def compile(self, force=False, missing_ok=False):
		if not force and self.uptodate():
			return
		self.to_html(missing_ok=missing_ok)
		self.to_pdf()


	def to_html(self, missing_ok=False):
		try:
			with open(self.md_path) as fd:
				md_text = fd.read()
		except FileNotFoundError:
			if missing_ok:
				md_text = '_Start typing your document!_'
			else:
				raise

		# FIXME: catch ModuleNotFoundError
		extensions = [
			'meta',
			'fenced_code',
			'tables',
			'attr_list',
			'sane_lists',
			'smarty',
			# 'markdown_checklist.extension',
			# 'markdown_strikethrough.extension',
		]
		parser = markdown.Markdown(extensions=extensions)
		html_text = parser.convert(md_text)
		meta = dict(parser.Meta)  # Copy, because we'll reuse parser
		Config.style_doc = ''.join(meta.get('style', [])) or None

		headers = []
		for name, tag in {'title': 'h1', 'subtitle': 'h2', 'date': 'p', 'author': 'p'}.items():
			try:
				txt = strip_p(parser.convert('<br>\n'.join(meta[name])))
				if name == 'date':
					txt = datetime.date.today().strftime(txt)
				headers.append(f'<{tag} class="{name}">{txt}</{tag}>')
			except KeyError:
				pass
		if headers:
			headers = '\n'.join(['<header>'] + headers + ['</header>'])
		else:
			headers = ''

		self.html = f'<html>\n<body>\n{headers}\n{html_text}\n</body>\n</html>\n'
		with open('out.html', 'w') as fd:
			fd.write(self.html)


	def to_pdf(self):
		font_config = weasyprint.text.fonts.FontConfiguration()
		wp = weasyprint.HTML(string=self.html, base_url=os.path.dirname(self.md_path))

		stylesheets = [weasyprint.CSS(filename=self.config.base_style_file, font_config=font_config)]
		style = self.config.style_file
		print(f'{style=}')
		if style:
			try:
				stylesheets.append(weasyprint.CSS(filename=style, font_config=font_config))
			except FileNotFoundError as e:
				print(e)
				pass
		print([s for s in stylesheets])

		# FIXME: papersize
		wp.write_pdf(self.pdf_path, stylesheets=stylesheets, font_config=font_config, presentational_hints=True)

	def __str__(self):
		return repr(self)


	def __repr__(self):
		return f'Document({self.md_path})'



class Config:
	@classmethod
	@property
	def system_styles_path(cls):
		return os.path.join(cls.install_path, 'style')

	@classmethod
	@property
	def user_styles_path(cls):
		return os.path.join(cls.config_path, 'style')

	@classmethod
	@property
	def base_style_file(cls):
		return cls.find_style('mdf/base')

	@classmethod
	def find_style(cls, name):
		skip_user = False
		if name.startswith('mdf/'):
			skip_user = True
			name = name[4:]

		system_style = os.path.join(cls.system_styles_path, name, 'style.css')
		user_style = os.path.join(cls.user_styles_path, name, 'style.css')

		if skip_user:
			return system_style

		if os.path.isfile(user_style):
			return user_style

		if os.path.isfile(system_style):
			return system_style

		return user_style

	@classmethod
	@property
	def style_file(cls):
		for style in [cls.style_cli, cls.style_doc, cls.style_default]:
			if style:
				return cls.find_style(style)
		return None

	@classmethod
	def find_styles_in(cls, path):
		return [style for style in os.listdir(path) if os.path.isfile(os.path.join(path, style, 'style.css'))]

	@classmethod
	def list_styles(cls):
		user_styles = cls.find_styles_in(cls.user_styles_path)
		system_styles = [
			f'mdf/{style}' if style in user_styles else style
			for style in cls.find_styles_in(cls.system_styles_path)
		]
		return user_styles + system_styles

Config.install_path = os.path.dirname(os.path.realpath(sys.argv[0]))
Config.config_path = os.path.expanduser('~/.mdf')
Config.style_default = 'default'
Config.style_doc = None
Config.style_cli = None
Config.editor = os.environ.get('VISUAL', os.environ.get('EDITOR', 'editor'))
Config.viewer = 'xdg-open'


logging.getLogger('weasyprint').addHandler(logging.StreamHandler(sys.stderr))
logging.getLogger('MARKDOWN').addHandler(logging.StreamHandler(sys.stderr))
##logger = logging.getLogger()
##logger.setLevel(logging.NOTSET)
#handler = logging.FileHandler('mdf.log')
#handler.setLevel(logging.NOTSET)
#format = '%(asctime)s %(levelname)8s: %(name)s.%(funcName)s -> %(message)s'
#handler.setFormatter(logging.Formatter(format))
##logger.addHandler(handler)
#logging.getLogger('weasyprint').setLevel(logging.NOTSET)
#logging.getLogger('weasyprint').addHandler(handler)


# Parse command line arguments
parser = argparse.ArgumentParser(description='Compile MarkDown document to a PDF. If no actions are specified, assume --edit --view.')
parser.add_argument('--compile', '-c', action='store_true', help='Compile document if out of date.')
parser.add_argument('--force-compile', '-C', action='store_true', help='Compile document, regardless.')
parser.add_argument('--watch', '-w', action='store_true', help='Watch document, compile if updated.')
parser.add_argument('--edit', '-e', action='store_true', help='Edit document, and watch for updates.')
parser.add_argument('--view', '-v', action='store_true', help='Launch PDF viewer for compiled document.')
parser.add_argument('--style', '-s', type=str, help="Use STYLE for format the document. Defaults to 'default'. Use '-' to disable.")
parser.add_argument('--list-styles', '-S', action='store_true', help='List available styles.')
parser.add_argument('file', type=str, nargs='*', help='Input MarkDown file(s).')
args = parser.parse_args()

if args.list_styles:
	for style in Config.list_styles():
		print(style)
	exit()

if args.style is not None:
	if args.style == '-':
		Config.style_default = None
	else:
		Config.style_cli = args.style

if not (args.compile or args.force_compile or args.watch or args.edit):
	args.edit = True
if args.edit:
	args.watch = True
	args.view = True
if args.watch:
	args.compile = True
if args.force_compile:
	args.compile = True

if not args.file:
	print('You must specify a file to edit/render.')
	exit(1)
documents = [Document(f, Config) for f in args.file]
print(documents)
print(f'Weasyprint v{weasyprint.VERSION}')



if args.compile:
	for d in documents:
		try:
			d.compile(force=args.force_compile, missing_ok=args.edit)
		except FileNotFoundError as e:
			print(e)
			exit()

if args.view:
	viewer_process = subprocess.Popen([Config.viewer] + [d.pdf_path for d in documents])

if args.edit:
	editor_process = subprocess.Popen([Config.editor] + [d.md_path for d in documents])
else:
	editor_process = None

try:
	if args.watch:
		while editor_process is None or editor_process.poll() is None:
			for d in documents:
				d.compile()
			time.sleep(0.1)  # FIXME: Yeah, polling :/
except KeyboardInterrupt:
	pass



#from html.parser import HTMLParser
#
#class MyHTMLParser(HTMLParser):
#	def __init__(self, *args, **kwargs):
#		super().__init__(*args, **kwargs)
#		self.output = ''
#
#	def handle_starttag(self, tag, attrs):
#		if tag == 'img':
#			print('IMAGE', attrs)
#
#parser = MyHTMLParser()
#
#parser.feed(html)
