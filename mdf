#! /usr/bin/python3

import os
import sys
import time
import shutil
import argparse
import tempfile
import subprocess


# FIXME: hmm, what to do with this?
def ensure_font(name):
	if name.encode('ascii') not in subprocess.run(['fc-match', name], stdout=subprocess.PIPE).stdout:
		print(f'Font "{name}" not found!')
		exit(1)
ensure_font('Candara')
ensure_font('Gentium Basic')



INSTALL_PATH = os.path.dirname(os.path.realpath(sys.argv[0]))

# Parse command line arguments
parser = argparse.ArgumentParser(description='Compile MarkDown document to a PDF. If no actions are specified, assume --edit --view.')
parser.add_argument('--compile', '-c', action='store_true', help='Compile document if out of date.')
parser.add_argument('--force-compile', '-C', action='store_true', help='Compile document, regardless.')
parser.add_argument('--watch', '-w', action='store_true', help='Watch document, compile if updated.')
parser.add_argument('--edit', '-e', action='store_true', help='Edit document, and watch for updates.')
parser.add_argument('--view', '-v', action='store_true', help='Launch PDF viewer for compiled document.')
parser.add_argument('file', type=str, nargs=None, help='Input MarkDown file(s).')
args = parser.parse_args()

if not (args.compile or args.force_compile or args.watch or args.edit):
	args.edit = True
if args.edit:
	args.watch = True
if args.watch:
	args.compile = True
if args.force_compile:
	args.compile = True



# Check if md doc is newer than pdf, and if so, compile it
def maybe_compile(md, imd, html, pdf):
	try:
		md_mtime = os.stat(md).st_mtime
	except FileNotFoundError:
		md_mtime = 0

	try:
		pdf_mtime = os.stat(pdf).st_mtime
	except FileNotFoundError:
		pdf_mtime = -1

	if md_mtime > pdf_mtime:
		compile(md_path, imd_path, html_path, pdf_path)



# Compile md doc into pdf
def compile(md, imd, html, pdf):
	try:
		shutil.copyfile(md, imd)
	except FileNotFoundError:
		with open(imd, 'w') as fd:
			pass

	print()
	print('Running pandoc')
	subprocess.run([
		'pandoc',
		'--from=markdown+yaml_metadata_block+smart+strikeout+link_attributes+raw_html',
		'--standalone',
		'--pdf-engine=wkhtmltopdf',
		'--to=html',
		f'--variable=css:{INSTALL_PATH}/style.css',
		'--output=' + html,
		imd,
	], stdout=sys.stdout, stderr=sys.stderr)

	print()
	print('Running wkhtmltopdf')
	subprocess.run([
		'wkhtmltopdf',
		'--enable-local-file-access',
		'-B', '10mm', '-T', '10mm', '-L', '10mm', '-R', '10mm',
		'-s', 'A4',
		html,
		pdf,
	], stdout=sys.stdout, stderr=sys.stderr)



# Set up files
tmp_dir = tempfile.TemporaryDirectory(prefix='mdf.')
md_path = args.file
if not md_path.endswith('.md'):
	md_path += '.md'
pdf_path = os.path.splitext(md_path)[0] + '.pdf'
imd_path = f'{tmp_dir.name}/input.md'
html_path = f'{tmp_dir.name}/output.html'
log_path = f'{tmp_dir.name}/mdf.log'



# Fix stdout/err, log file
old_stdout = sys.stdout
old_stderr = sys.stderr
sys.stdout = open(log_path, 'w', buffering=1)
sys.stderr = sys.stdout



# Let's go
print(f'tmp_dir = {tmp_dir}')
if args.compile:
	if args.force_compile:
		compile(md_path, imd_path, html_path, pdf_path)
	else:
		maybe_compile(md_path, imd_path, html_path, pdf_path)

if args.view:
	evince_process = subprocess.Popen(['evince', pdf_path], stdout=sys.stdout, stderr=sys.stderr)

if args.edit:
	vim_process = subprocess.Popen(['vim', md_path])
else:
	vim_process = None

if args.watch:
	while vim_process is None or vim_process.poll() is None:
		maybe_compile(md_path, imd_path, html_path, pdf_path)
		time.sleep(0.1)  # Yeah, polling :/
